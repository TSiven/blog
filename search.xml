<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis Sentinel集群方案--单机版]]></title>
    <url>%2F%2F2017%2F09%2F15%2FRedis-Sentinel%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88-%E5%8D%95%E6%9C%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[简单介绍下Redis-sentinel：Redis-sentinel是Redis实例的监控管理、通知和实例失效备援服务，是Redis集群的管理工具。在一般的分布式中心节点数据库中，Redis-sentinel的作用是中心节点的工作，监控各个其他节点的工作情况并且进行故障恢复，来提高集群的高可用性。Sentinel是一个独立于Redis之外的进程，不对外提供key/value服务，存在redis的安装目录下Redis-sentinel。主要用来监控redis-server进程，进行master/slave管理，如果Redis没有运行在master/slave模式下，则不需要设置sentinel。 下面例子中用了3个redis-server和3个redis-sentinel来进行安装演示，实际上redis-sentinel的个数不一定要和redis-sever对应，1~n 个都可以，建议redis-server为偶数个。 部署规划注： 以下各个节点都在同一个服务器中进行演练master:7000slave1: 7001slave2: 7002master-sentinel: 8000slave1-sentinel: 8001slave2-sentinel: 8002 下载安装redis123456cdwget http://download.redis.io/releases/redis-2.8.3.tar.gztar –zxvf redis-2.8.3.tar.gzcd redis-2.8.3makemake install(此处可用PREFIX参数将redis安装到其他目录) 配置环境创建目录12345cd /usr/localmkdir redis_clustermkdir redis_cluster/master_7000mkdir redis_cluster/slave_7001mkdir redis_cluster/slave_7002 复制配置文件从安装包中复制redis.conf,sentinel.conf配置文件到新建的各个节点目录, 如下: 复制文件到master目录12cp ~/redis-2.8.3/redis.conf ./redis_cluster/master_7000/cp ~/redis-2.8.3/sentinel.conf ./redis_cluster/master_7000/sentinel.conf 复制文件到slave1目录12cp ~/redis-2.8.3/redis.conf ./redis_cluster/slave_7001/cp ~/redis-2.8.3/sentinel.conf ./redis_cluster/slave_7001/sentinel.conf 复制文件到slave2目录12cp ~/redis-2.8.3/redis.conf ./redis_cluster/slave_7002/cp ~/redis-2.8.3/sentinel.conf ./redis_cluster/slave_7002/sentinel.conf 配置文件配置Master节点redis.conf1234567daemonize yespidfile /var/run/redis_7000.pidport 7000requirepass servyou #从服务器从主服务器同步时的认证密码，如果master设置了，slave密码必须设置，反之master没设置，则slave也无需设置masterauth servyou #设置Redis连接密码,如果配置了连接密码,客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码appendonly noslave-read-only yes sentinel.conf123456789101112131415161718daemonize yeslogfile &quot;/usr/local/redis_cluster/master_7000/log/sentinel_log.log&quot;#指定sentinel使用的端口，不能与redis-server运行实例的端口冲突port 8000 #指定工作目录dir /tmp ####sentinel需要监控的master信息：&lt;mastername&gt; &lt;masterIP&gt; &lt;masterPort&gt; &lt;quorum&gt;.####&lt;quorum&gt;应该小于集群中slave的个数,只有当至少&lt;quorum&gt;个sentinel实例提交&quot;master失效&quot; 才会认为master为ODWON(&quot;客观&quot;失效) .ssentinel monitor mymaster 127.0.0.1 7000 2 #设置访问mymaster的密码sentinel auth-pass mymaster servyou #表示如果3s内mymaster没响应，就认为SDOWNsentinel down-after-milliseconds mymaster 30000 #表示如果15秒后,mysater仍没活过来，则启动failover，从剩下的slave中选一个升级为mastersentinel failover-timeout mymaster 15000 #表示如果master重新选出来后，其它slave节点能同时并行从新master同步缓存的台数有多少个，显然该值越大，所有slave节点完成同步切换的整体速度越快，但如果此时正好有人在访问这些slave，可能造成读取失败，影响面会更广。最保定的设置为1，只同一时间，只能有一台干这件事，这样其它slave还能继续服务，但是所有slave全部完成缓存更新同步的进程将变慢。sentinel parallel-syncs mymaster 1 配置Slave1节点redis.conf12345678daemonize yespidfile /var/run/redis_7001.pidport 7001requirepass servyoumasterauth servyouappendonly noslave-read-only yesslave of 127.0.0.1 7000 sentinel.conf123456789daemonize yeslogfile &quot;/usr/local/redis_cluster/slave_7001/log/sentinel_log.log&quot;port 8001dir /tmpsentinel monitor mymaster 127.0.0.1 7000 2sentinel auth-pass mymaster servyousentinel down-after-milliseconds mymaster 30000sentinel parallel-syncs mymaster 1sentinel failover-timeout mymaster 15000 配置Slave2节点配置与Slave1几乎一致 redis.conf12345678daemonize yespidfile /var/run/redis_7002.pidport 7002requirepass servyoumasterauth servyouappendonly noslave-read-only yesslave of 127.0.0.1 7000 sentinel.conf123456789daemonize yeslogfile &quot;/usr/local/redis_cluster/slave_7002/log/sentinel_log.log&quot;port 8002dir /tmpsentinel monitor mymaster 127.0.0.1 7000 2sentinel auth-pass mymaster servyousentinel down-after-milliseconds mymaster 30000sentinel parallel-syncs mymaster 1sentinel failover-timeout mymaster 15000 启动服务注意：首次构建sentinel环境时，必须首先启动master。 启动master和master-sentinel12redis-server /usr/local/redis_cluster/master_7000/redis.confredis-sentinel usr/local/redis_cluster/master_7000/sentinel.conf 启动slave1和slave1-sentinel12redis-server /usr/local/redis_cluster/slave_7001/redis.confredis-sentinel /usr/local/redis_cluster/slave_7001/sentinel.conf 启动slave2和slave2-sentinel12redis-server /usr/local/redis_cluster/slave_7002/redis.confredis-sentinel /usr/local/redis_cluster/slave_7002/sentinel.conf 查看进程 查看状态 info Replication 查看master状态1redis-cli -h 127.0.0.1 -p 7000 查看slave1状态1redis-cli -h 127.0.0.1 -p 7001 查看slave2状态1redis-cli -h 127.0.0.1 -p 7002 场景测试场景1: slave宕机关闭slave1：查看master的Replication信息：此时只存在一个slave。 场景2：slave恢复重新开启slave1 查看sentinel状态：sentinel能快速的发现slave加入到集群中：查看master的Replication信息： 场景3：master宕机master-sentinel作为master 1的leader，会选取一个master 1的slave作为新的master。slave的选取是根据一个判断DNS情况的优先级来得到，优先级相同通过runid的排序得到，但目前优先级设定还没实现，所以直接获取runid排序得到slave 1。然后发送命令slaveof no one来取消slave 1的slave状态来转换为master。当其他sentinel观察到该slave成为master后,就知道错误处理例程启动了。sentinel A然后发送给其他slave slaveof new-slave-ip-port 命令，当所有slave都配置完后，sentinel A从监测的masters列表中删除故障master，然后通知其他sentinels。 场景4：master恢复重新启动原来的master 查看sentinel状态：原来的master自动切换成slave，不会自动恢复成master： 连接到slave2,可以看到目前有两个子节点了 好了, 测试完成! 注意：若在sentinel已选出新主但尚未完成其它实例的reconfigure之前，重启old master，则整个系统会出现无法选出new master的异常。]]></content>
      <categories>
        <category>Redis</category>
        <category>Sentinel</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Sentinel</tag>
        <tag>Redis 集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA使用MyBatis-generator自动生成MyBatis代码]]></title>
    <url>%2F%2F2017%2F09%2F12%2FIntellij-IDEA%E4%BD%BF%E7%94%A8MyBatis-generator%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90MyBatis%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[STEP 1. 新增maven插件在maven项目的pom.xml 添加mybatis-generator-maven-plugin 插件1234567891011121314&lt;build&gt; &lt;finalName&gt;xxx&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; STEP 2. 新建generatorConfig.xml的配置文件在maven项目下的src/main/resources 目录下建立名为 generatorConfig.xml的配置文件，作为mybatis-generator-maven-plugin 插件的执行目标，模板如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt; &lt;generatorConfiguration&gt; &lt;!--导入属性配置 --&gt; &lt;properties resource="generator.properties"&gt;&lt;/properties&gt; &lt;!--指定特定数据库的jdbc驱动jar包的位置 --&gt; &lt;classPathEntry location="$&#123;jdbc.driverLocation&#125;"/&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;jdbc.driverClass&#125;" connectionURL="$&#123;jdbc.connectionURL&#125;" userId="$&#123;jdbc.userId&#125;" password="$&#123;jdbc.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;javaModelGenerator targetPackage="org.louis.hometutor.po" targetProject="src/main/java"&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name="constructorBased" value="true"/&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name="immutable" value="true"/&gt; &lt;!-- 给Model添加一个父类 --&gt; &lt;property name="rootClass" value="com.foo.louis.Hello"/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;sqlMapGenerator targetPackage="org.louis.hometutor.domain" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象 type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator targetPackage="com.foo.tourist.dao" targetProject="src/main/java" type="MIXEDMAPPER"&gt; &lt;property name="enableSubPackages" value=""/&gt; &lt;!-- 定义Maper.java 源代码中的ByExample() 方法的可视性，可选的值有： public; private; protected; default 注意：如果 targetRuntime="MyBatis3",此参数被忽略 --&gt; &lt;property name="exampleMethodVisibility" value=""/&gt; &lt;!-- 方法名计数器 Important note: this property is ignored if the target runtime is MyBatis3. --&gt; &lt;property name="methodNameCalculator" value=""/&gt; &lt;!-- 为生成的接口添加父接口 --&gt; &lt;property name="rootInterface" value=""/&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="lession" schema="louis"&gt; &lt;!-- optional , only for mybatis3 runtime 自动生成的键值（identity,或者序列值） 如果指定此元素，MBG将会生成&lt;selectKey&gt;元素，然后将此元素插入到SQL Map的&lt;insert&gt; 元素之中 sqlStatement 的语句将会返回新的值 如果是一个自增主键的话，你可以使用预定义的语句,或者添加自定义的SQL语句. 预定义的值如下: Cloudscape This will translate to: VALUES IDENTITY_VAL_LOCAL() DB2: VALUES IDENTITY_VAL_LOCAL() DB2_MF: SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 Derby: VALUES IDENTITY_VAL_LOCAL() HSQLDB: CALL IDENTITY() Informix: select dbinfo('sqlca.sqlerrd1') from systables where tabid=1 MySql: SELECT LAST_INSERT_ID() SqlServer: SELECT SCOPE_IDENTITY() SYBASE: SELECT @@IDENTITY JDBC: This will configure MBG to generate code for MyBatis3 suport of JDBC standard generated keys. This is a database independent method of obtaining the value from identity columns. identity: 自增主键 If true, then the column is flagged as an identity column and the generated &lt;selectKey&gt; element will be placed after the insert (for an identity column). If false, then the generated &lt;selectKey&gt; will be placed before the insert (typically for a sequence). --&gt; &lt;generatedKey column="" sqlStatement="" identity="" type=""/&gt; &lt;!-- optional. 列的命名规则： MBG使用 &lt;columnRenamingRule&gt; 元素在计算列名的对应 名称之前，先对列名进行重命名， 作用：一般需要对BUSI_CLIENT_NO 前的BUSI_进行过滤 支持正在表达式 searchString 表示要被换掉的字符串 replaceString 则是要换成的字符串，默认情况下为空字符串，可选 --&gt; &lt;columnRenamingRule searchString="" replaceString=""/&gt; &lt;!-- optional.告诉 MBG 忽略某一列 column，需要忽略的列 delimitedColumnName:true ,匹配column的值和数据库列的名称 大小写完全匹配，false 忽略大小写匹配 是否限定表的列名，即固定表列在Model中的名称 --&gt; &lt;ignoreColumn column="PLAN_ID" delimitedColumnName="true" /&gt; &lt;!--optional.覆盖MBG对Model 的生成规则 column: 数据库的列名 javaType: 对应的Java数据类型的完全限定名 在必要的时候可以覆盖由JavaTypeResolver计算得到的java数据类型. For some databases, this is necessary to handle "odd" database types (e.g. MySql's unsigned bigint type should be mapped to java.lang.Object). jdbcType:该列的JDBC数据类型(INTEGER, DECIMAL, NUMERIC, VARCHAR, etc.)，该列可以覆盖由JavaTypeResolver计算得到的Jdbc类型，对某些数据库而言，对于处理特定的JDBC 驱动癖好 很有必要(e.g. DB2's LONGVARCHAR type should be mapped to VARCHAR for iBATIS). typeHandler: --&gt; &lt;columnOverride column="" javaType="" jdbcType="" typeHandler="" delimitedColumnName="" /&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 配置文件generator.properties属性文件这里使用了外置的配置文件generator.properties，可以将一下属性配置到properties文件之中，增加配置的灵活性：12345jdbc.driverLocation=D:\\maven\\com\\oracle\\ojdbc14\\10.2.0.4.0\\ojdbc14-10.2.0.4.0.jar jdbc.driverClass=oracle.jdbc.driver.OracleDriver jdbc.connectionURL=jdbc:oracle:thin:@//localhost:1521/XE jdbc.userId=LOUIS jdbc.password=123456 项目目录 STEP 3. 新增maven运行选项在Intellij IDEA添加一个“Run运行”选项，使用maven运行mybatis-generator-maven-plugin插件 ： 之后弹出运行配置框，为当前配置配置一个名称，这里其名为”generator”,然后在 “Command line” 选项中输入“mybatis-generator:generate -e” 这里加了“-e ”选项是为了让该插件输出详细信息，这样可以帮助我们定位问题。 如果添加成功，则会在run 选项中有“generator” 选项，如下： 点击运行，然后不出意外的话，会在控制台输出：12345678910111213141516171819202122232425262728293031323334C:\Java\jdk1.7.0_71\bin\java -Dmaven.home=D:\software\apache-maven-3.0.5-bin -Dclassworlds.conf=D:\software\apache-maven-3.0.5-bin\bin\m2.conf -Didea.launcher.port=7533 &quot;-Didea.launcher.bin.path=D:\applications\JetBrains\IntelliJ IDEA 14.0.2\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;D:\software\apache-maven-3.0.5-bin\boot\plexus-classworlds-2.4.jar;D:\applications\JetBrains\IntelliJ IDEA 14.0.2\lib\idea_rt.jar&quot; com.intellij.rt.execution.application.AppMain org.codehaus.classworlds.Launcher -Didea.version=14.0.2 -s D:\software\apache-maven-3.0.5-bin\conf\settings.xml mybatis-generator:generate -e [INFO] Error stacktraces are turned on. [INFO] Scanning for projects... [INFO] [INFO] ------------------------------------------------------------------------ [INFO] Building hometutor Maven Webapp 1.0-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] [INFO] --- mybatis-generator-maven-plugin:1.3.2:generate (default-cli) @ hometutor --- [INFO] Connecting to the Database [INFO] Introspecting table louis.lession log4j:WARN No appenders could be found for logger (org.mybatis.generator.internal.db.DatabaseIntrospector). log4j:WARN Please initialize the log4j system properly. log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. [INFO] Generating Example class for table LOUIS.LESSION [INFO] Generating Record class for table LOUIS.LESSION [INFO] Generating Mapper Interface for table LOUIS.LESSION [INFO] Generating SQL Map for table LOUIS.LESSION [INFO] Saving file LessionMapper.xml [INFO] Saving file LessionExample.java [INFO] Saving file Lession.java [INFO] Saving file LessionMapper.java [WARNING] Root class com.foo.louis.Hello cannot be loaded, checking for member overrides is disabled for this class [WARNING] Existing file E:\sources\tutor\src\main\java\org\louis\hometutor\po\Lession.java was overwritten [WARNING] Existing file E:\sources\tutor\src\main\java\com\foo\tourist\dao\LessionMapper.java was overwritten [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 2.334s [INFO] Finished at: Tue Jan 27 12:04:08 CST 2015 [INFO] Final Memory: 8M/107M [INFO] ------------------------------------------------------------------------ Process finished with exit code 0 好，看到BUILD SUCCESS，则大功告成，如果有错误的话，由于添加了-e 选项，会把具体的详细错误信息打印出来的，根据错误信息修改即可]]></content>
      <categories>
        <category>JAVA</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Maven</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis配置 & 常规操作类封装]]></title>
    <url>%2F%2F2017%2F09%2F10%2FRedis%E9%85%8D%E7%BD%AE%20%26%20%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[直接上代码吧!! 抽象基础类12345678910111213141516171819202122232425262728293031import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.RedisSerializer;public abstract class AbstractBaseRedis&lt;K, V&gt; &#123; @Autowired protected RedisTemplate&lt;K, V&gt; redisTemplate; @Autowired StringRedisTemplate stringRedisTemplate; /** * 设置redisTemplate * @param redisTemplate the redisTemplate to set */ public void setRedisTemplate(RedisTemplate&lt;K, V&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 获取 String RedisSerializer * &lt;br&gt;------------------------------&lt;br&gt; */ protected RedisSerializer&lt;String&gt; getStringSerializer() &#123; return redisTemplate.getStringSerializer(); &#125;&#125; JsonMapper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235import java.io.IOException;import java.util.TimeZone;import org.apache.commons.lang3.StringEscapeUtils;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.alibaba.fastjson.JSON;import com.fasterxml.jackson.annotation.JsonInclude.Include;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.core.JsonParser.Feature;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.JsonSerializer;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import com.fasterxml.jackson.databind.SerializerProvider;import com.fasterxml.jackson.databind.module.SimpleModule;import com.fasterxml.jackson.databind.util.JSONPObject;public class JsonMapper extends ObjectMapper &#123; private static final long serialVersionUID = 1L; private final static Logger LOGGER = LoggerFactory.getLogger(JsonMapper.class); private static JsonMapper mapper; public JsonMapper() &#123; this(Include.NON_EMPTY); &#125; public JsonMapper(Include include) &#123; // 设置输出时包含属性的风格 if (include != null) &#123; this.setSerializationInclusion(include); &#125; // 设置输入时忽略在JSON字符串中存在但Java对象实际没有的属性 this.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); // 空值处理为空串 this.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;()&#123; @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException &#123; jgen.writeString(""); &#125; &#125;); // 进行HTML解码。 this.registerModule(new SimpleModule().addSerializer(String.class, new JsonSerializer&lt;String&gt;()&#123; @Override public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException &#123; jgen.writeString(StringEscapeUtils.unescapeHtml4(value)); &#125; &#125;)); // 设置时区 this.setTimeZone(TimeZone.getDefault());//getTimeZone("GMT+8:00") &#125; /** * 创建只输出非Null且非Empty(如List.isEmpty)的属性到Json字符串的Mapper,建议在外部接口中使用. */ public static JsonMapper getInstance() &#123; if (mapper == null)&#123; mapper = new JsonMapper().enableSimple(); &#125; return mapper; &#125; /** * 创建只输出初始值被改变的属性到Json字符串的Mapper, 最节约的存储方式，建议在内部接口中使用。 */ public static JsonMapper nonDefaultMapper() &#123; if (mapper == null)&#123; mapper = new JsonMapper(Include.NON_DEFAULT); &#125; return mapper; &#125; /** * Object可以是POJO，也可以是Collection或数组。 * 如果对象为Null, 返回"null". * 如果集合为空集合, 返回"[]". */ public String toJson(Object object) &#123; try &#123; return this.writeValueAsString(object); &#125; catch (IOException e) &#123; if(LOGGER.isWarnEnabled())&#123; LOGGER.warn("write to json string error:" + object, e); &#125; return null; &#125; &#125; /** * 反序列化POJO或简单Collection如List&lt;String&gt;. * * 如果JSON字符串为Null或"null"字符串, 返回Null. * 如果JSON字符串为"[]", 返回空集合. * * 如需反序列化复杂Collection如List&lt;MyBean&gt;, 请使用fromJson(String,JavaType) * @see #fromJson(String, JavaType) */ public &lt;T&gt; T fromJson(String jsonString, Class&lt;T&gt; clazz) &#123; if (StringUtils.isEmpty(jsonString)) &#123; return null; &#125; try &#123; return this.readValue(jsonString, clazz); &#125; catch (IOException e) &#123; if(LOGGER.isWarnEnabled())&#123; LOGGER.warn("parse json string error:" + jsonString, e); &#125; return null; &#125; &#125; /** * 反序列化复杂Collection如List&lt;Bean&gt;, 先使用函數createCollectionType构造类型,然后调用本函数. * @see #createCollectionType(Class, Class...) */ @SuppressWarnings("unchecked") public &lt;T&gt; T fromJson(String jsonString, JavaType javaType) &#123; if (StringUtils.isEmpty(jsonString)) &#123; return null; &#125; try &#123; return (T) this.readValue(jsonString, javaType); &#125; catch (IOException e) &#123; if(LOGGER.isWarnEnabled())&#123; LOGGER.warn("parse json string error:" + jsonString, e); &#125; return null; &#125; &#125; /** * 構造泛型的Collection Type如: * ArrayList&lt;MyBean&gt;, 则调用constructCollectionType(ArrayList.class,MyBean.class) * HashMap&lt;String,MyBean&gt;, 则调用(HashMap.class,String.class, MyBean.class) */ public JavaType createCollectionType(Class&lt;?&gt; collectionClass, Class&lt;?&gt;... elementClasses) &#123; return this.getTypeFactory().constructParametricType(collectionClass, elementClasses); &#125; /** * 當JSON裡只含有Bean的部分屬性時，更新一個已存在Bean，只覆蓋該部分的屬性. */ @SuppressWarnings("unchecked") public &lt;T&gt; T update(String jsonString, T object) &#123; try &#123; return (T) this.readerForUpdating(object).readValue(jsonString); &#125; catch (JsonProcessingException e) &#123; if(LOGGER.isWarnEnabled())&#123; LOGGER.warn("update json string:" + jsonString + " to object:" + object + " error.", e); &#125; &#125; catch (IOException e) &#123; if(LOGGER.isWarnEnabled())&#123; LOGGER.warn("update json string:" + jsonString + " to object:" + object + " error.", e); &#125; &#125; return null; &#125; /** * 輸出JSONP格式數據. */ public String toJsonP(String functionName, Object object) &#123; return toJson(new JSONPObject(functionName, object)); &#125; /** * 設定是否使用Enum的toString函數來讀寫Enum, * 為False時時使用Enum的name()函數來讀寫Enum, 默認為False. * 注意本函數一定要在Mapper創建後, 所有的讀寫動作之前調用. */ public JsonMapper enableEnumUseToString() &#123; this.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING); this.enable(DeserializationFeature.READ_ENUMS_USING_TO_STRING); return this; &#125; /** * 允许单引号 * 允许不带引号的字段名称 */ public JsonMapper enableSimple() &#123; this.configure(Feature.ALLOW_SINGLE_QUOTES, true); this.configure(Feature.ALLOW_UNQUOTED_FIELD_NAMES, true); return this; &#125; /** * 取出Mapper做进一步的设置或使用其他序列化API. */ public ObjectMapper getMapper() &#123; return this; &#125; /** * 对象转换为JSON字符串 * @param object * @return */ public static String toJsonString(Object object)&#123; return JsonMapper.getInstance().toJson(object); &#125; /** * JSON字符串转换为对象 * @param jsonString * @param clazz * @return */ public static &lt;T&gt; T fromJsonString(String jsonString, Class&lt;T&gt; clazz)&#123; return JsonMapper.getInstance().fromJson(jsonString, clazz); &#125; /** * 将obj对象转换成 class类型的对象 * @param obj * @param clazz * @return */ public static &lt;T&gt; T parseObject(Object obj, Class&lt;T&gt; clazz)&#123; return JSON.parseObject(JSON.toJSONString(obj), clazz); &#125;&#125; JSON序列化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.lang3.SerializationException;import java.nio.charset.Charset;/** * Created by SIVEN on 17/9/4. */public class JsonRedisSeriaziler &#123; public static final String EMPTY_JSON = "&#123;&#125;"; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); protected ObjectMapper objectMapper = new ObjectMapper(); public JsonRedisSeriaziler()&#123;&#125; /** * java-object as json-string * @param object * @return */ public String seriazileAsString(Object object)&#123; if (object== null) &#123; return EMPTY_JSON; &#125; try &#123; return this.objectMapper.writeValueAsString(object); &#125; catch (Exception ex) &#123; throw new SerializationException("Could not write JSON: " + ex.getMessage(), ex); &#125; &#125; /** * json-string to java-object * @param str * @return */ public &lt;T&gt; T deserializeAsObject(String str,Class&lt;T&gt; clazz)&#123; if(str == null || clazz == null)&#123; return null; &#125; try&#123; return this.objectMapper.readValue(str, clazz); &#125;catch (Exception ex) &#123; throw new SerializationException("Could not write JSON: " + ex.getMessage(), ex); &#125; &#125;&#125; RedisClient123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import org.apache.commons.lang3.StringUtils;import org.springframework.dao.DataAccessException;import org.springframework.data.redis.connection.RedisConnection;import org.springframework.data.redis.core.BoundHashOperations;import org.springframework.data.redis.core.RedisCallback;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Repository;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;@Repositorypublic class RedisClient extends AbstractBaseRedis&lt;String, Object&gt; &#123; /** * 删除缓存&lt;br&gt; * 根据key精确匹配删除 * @param key */ @SuppressWarnings("unchecked") public void del(String... key)&#123; if(key!=null &amp;&amp; key.length &gt; 0)&#123; if(key.length == 1)&#123; redisTemplate.delete(key[0]); &#125;else&#123; redisTemplate.delete(CollectionUtils.arrayToList(key)); &#125; &#125; &#125; /** * 批量删除&lt;br&gt; * （该操作会执行模糊查询，请尽量不要使用，以免影响性能或误删） * @param pattern */ public void batchDel(String... pattern)&#123; for (String kp : pattern) &#123; redisTemplate.delete(redisTemplate.keys(kp + "*")); &#125; &#125; /** * 取得缓存（int型） * @param key * @return */ public Integer getInt(String key)&#123; String value = stringRedisTemplate.boundValueOps(key).get(); if(StringUtils.isNotBlank(value))&#123; return Integer.valueOf(value); &#125; return null; &#125; /** * 取得缓存（字符串类型） * @param key * @return */ public String getStr(String key)&#123; return stringRedisTemplate.boundValueOps(key).get(); &#125; /** * 取得缓存（字符串类型） * @param key * @return */ public String getStr(String key, boolean retain)&#123; String value = stringRedisTemplate.boundValueOps(key).get(); if(!retain)&#123; redisTemplate.delete(key); &#125; return value; &#125; /** * 获取缓存&lt;br&gt; * 注：基本数据类型(Character除外)，请直接使用get(String key, Class&lt;T&gt; clazz)取值 * @param key * @return */ public Object getObj(String key)&#123; return redisTemplate.boundValueOps(key).get(); &#125; /** * 获取缓存&lt;br&gt; * 注：java 8种基本类型的数据请直接使用get(String key, Class&lt;T&gt; clazz)取值 * @param key * @param retain 是否保留 * @return */ public Object getObj(String key, boolean retain)&#123; Object obj = redisTemplate.boundValueOps(key).get(); if(!retain)&#123; redisTemplate.delete(key); &#125; return obj; &#125; /** * 获取缓存&lt;br&gt; * 注：该方法暂不支持Character数据类型 * @param key key * @param clazz 类型 * @return */ @SuppressWarnings("unchecked") public &lt;T&gt; T get(String key, Class&lt;T&gt; clazz) &#123; return (T)redisTemplate.boundValueOps(key).get(); &#125; /** * 获取缓存json对象&lt;br&gt; * @param key key * @param clazz 类型 * @return */ public &lt;T&gt; T getJson(String key, Class&lt;T&gt; clazz) &#123; return JsonMapper.fromJsonString(stringRedisTemplate.boundValueOps(key).get(), clazz); &#125; /** * 将value对象写入缓存 * @param key * @param value * @param time 失效时间(秒) */ public void set(String key,Object value,Long time)&#123; if(value.getClass().equals(String.class))&#123; stringRedisTemplate.opsForValue().set(key, value.toString()); &#125;else if(value.getClass().equals(Integer.class))&#123; stringRedisTemplate.opsForValue().set(key, value.toString()); &#125;else if(value.getClass().equals(Double.class))&#123; stringRedisTemplate.opsForValue().set(key, value.toString()); &#125;else if(value.getClass().equals(Float.class))&#123; stringRedisTemplate.opsForValue().set(key, value.toString()); &#125;else if(value.getClass().equals(Short.class))&#123; stringRedisTemplate.opsForValue().set(key, value.toString()); &#125;else if(value.getClass().equals(Long.class))&#123; stringRedisTemplate.opsForValue().set(key, value.toString()); &#125;else if(value.getClass().equals(Boolean.class))&#123; stringRedisTemplate.opsForValue().set(key, value.toString()); &#125;else&#123; redisTemplate.opsForValue().set(key, value); &#125; if(time &gt; 0)&#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; &#125; /** * 将value对象以JSON格式写入缓存 * @param key * @param value * @param time 失效时间(秒) */ public void setJson(String key,Object value,Long time)&#123; stringRedisTemplate.opsForValue().set(key, JsonMapper.toJsonString(value)); if(time &gt; 0)&#123; stringRedisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; &#125; /** * 更新key对象field的值 * @param key 缓存key * @param field 缓存对象field * @param value 缓存对象field值 */ public void setJsonField(String key, String field, String value)&#123; JSONObject obj = JSON.parseObject(stringRedisTemplate.boundValueOps(key).get()); obj.put(field, value); stringRedisTemplate.opsForValue().set(key, obj.toJSONString()); &#125; /** * 递减操作 * @param key * @param by * @return */ public double decr(String key, double by)&#123; return redisTemplate.opsForValue().increment(key, -by); &#125; /** * 递增操作 * @param key * @param by * @return */ public double incr(String key, double by)&#123; return redisTemplate.opsForValue().increment(key, by); &#125; /** * 获取double类型值 * @param key * @return */ public double getDouble(String key) &#123; String value = stringRedisTemplate.boundValueOps(key).get(); if(StringUtils.isNotBlank(value))&#123; return Double.valueOf(value); &#125; return 0d; &#125; /** * 设置double类型值 * @param key * @param value * @param time 失效时间(秒) */ public void setDouble(String key, double value, Long time) &#123; stringRedisTemplate.opsForValue().set(key, String.valueOf(value)); if(time &gt; 0)&#123; stringRedisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; &#125; /** * 设置double类型值 * @param key * @param value * @param time 失效时间(秒) */ public void setInt(String key, int value, Long time) &#123; stringRedisTemplate.opsForValue().set(key, String.valueOf(value)); if(time &gt; 0)&#123; stringRedisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; &#125; /** * 将map写入缓存 * @param key * @param map * @param time 失效时间(秒) */ public &lt;T&gt; void setMap(String key, Map&lt;String, T&gt; map, Long time)&#123; redisTemplate.opsForHash().putAll(key, map); &#125; /** * 将map写入缓存 * @param key * @param map * @param time 失效时间(秒) */ @SuppressWarnings("unchecked") public &lt;T&gt; void setMap(String key, T obj, Long time)&#123; Map&lt;String, String&gt; map = (Map&lt;String, String&gt;)JsonMapper.parseObject(obj, Map.class); redisTemplate.opsForHash().putAll(key, map); &#125; /** * 向key对应的map中添加缓存对象 * @param key * @param map */ public &lt;T&gt; void addMap(String key, Map&lt;String, T&gt; map)&#123; redisTemplate.opsForHash().putAll(key, map); &#125; /** * 向key对应的map中添加缓存对象 * @param key cache对象key * @param field map对应的key * @param value 值 */ public void addMap(String key, String field, String value)&#123; redisTemplate.opsForHash().put(key, field, value); &#125; /** * 向key对应的map中添加缓存对象 * @param key cache对象key * @param field map对应的key * @param obj 对象 */ public &lt;T&gt; void addMap(String key, String field, T obj)&#123; redisTemplate.opsForHash().put(key, field, obj); &#125; /** * 获取map缓存 * @param key * @param clazz * @return */ public &lt;T&gt; Map&lt;String, T&gt; mget(String key, Class&lt;T&gt; clazz)&#123; BoundHashOperations&lt;String, String, T&gt; boundHashOperations = redisTemplate.boundHashOps(key); return boundHashOperations.entries(); &#125; /** * 获取map缓存 * @param key * @param clazz * @return */ public &lt;T&gt; T getMap(String key, Class&lt;T&gt; clazz)&#123; BoundHashOperations&lt;String, String, String&gt; boundHashOperations = redisTemplate.boundHashOps(key); Map&lt;String, String&gt; map = boundHashOperations.entries(); return JsonMapper.parseObject(map, clazz); &#125; /** * 获取map缓存中的某个对象 * @param key * @param field * @param clazz * @return */ @SuppressWarnings("unchecked") public &lt;T&gt; T getMapField(String key, String field, Class&lt;T&gt; clazz)&#123; return (T)redisTemplate.boundHashOps(key).get(field); &#125; /** * 删除map中的某个对象 * @author lh * @date 2016年8月10日 * @param key map对应的key * @param field map中该对象的key */ public void delMapField(String key, String... field)&#123; BoundHashOperations&lt;String, String, ?&gt; boundHashOperations = redisTemplate.boundHashOps(key); boundHashOperations.delete(field); &#125; /** * 指定缓存的失效时间 * * @author FangJun * @date 2016年8月14日 * @param key 缓存KEY * @param time 失效时间(秒) */ public void expire(String key, Long time) &#123; if(time &gt; 0)&#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; &#125; /** * 添加set * @param key * @param value */ public void sadd(String key, String... value) &#123; redisTemplate.boundSetOps(key).add(value); &#125; /** * 删除set集合中的对象 * @param key * @param value */ public void srem(String key, String... value) &#123; redisTemplate.boundSetOps(key).remove(value); &#125; /** * set重命名 * @param oldkey * @param newkey */ public void srename(String oldkey, String newkey)&#123; redisTemplate.boundSetOps(oldkey).rename(newkey); &#125; /** * 短信缓存 * @author fxl * @date 2016年9月11日 * @param key * @param value * @param time */ public void setIntForPhone(String key,Object value,int time)&#123; stringRedisTemplate.opsForValue().set(key, JsonMapper.toJsonString(value)); if(time &gt; 0)&#123; stringRedisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; &#125; /** * 模糊查询keys * @param pattern * @return */ public Set&lt;String&gt; keys(String pattern)&#123; return redisTemplate.keys(pattern); &#125;&#125; redis xml文件配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd" default-lazy-init="false"&gt; &lt;description&gt;Jedis Config&lt;/description&gt; &lt;context:property-placeholder location="classpath:config/application-jedis.properties" ignore-unresolvable="true"/&gt; &lt;!-- 连接池配置. --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 连接池中最大连接数。高版本：maxTotal，低版本：maxActive --&gt; &lt;property name="maxTotal" value="$&#123;redis.maxTotal&#125;"/&gt; &lt;!-- 连接池中最大空闲的连接数. --&gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;"/&gt; &lt;!-- 连接池中最少空闲的连接数. --&gt; &lt;property name="minIdle" value="$&#123;redis.minIdle&#125;"/&gt; &lt;!-- 当连接池资源耗尽时，调用者最大阻塞的时间，超时将跑出异常。单位，毫秒数;默认为-1.表示永不超时。高版本：maxWaitMillis，低版本：maxWait --&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWaitMillis&#125;"/&gt; &lt;!-- 连接空闲的最小时间，达到此值后空闲连接将可能会被移除。负值(-1)表示不移除. --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;redis.minEvictableIdleTimeMillis&#125;"/&gt; &lt;!-- 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3 --&gt; &lt;property name="numTestsPerEvictionRun" value="$&#123;redis.numTestsPerEvictionRun&#125;"/&gt; &lt;!-- “空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1. --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;redis.timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;!-- testOnBorrow:向调用者输出“链接”资源时，是否检测是有有效，如果无效则从连接池中移除，并尝试获取继续获取。默认为false。建议保持默认值. --&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;"/&gt; &lt;!-- testOnReturn:向连接池“归还”链接时，是否检测“链接”对象的有效性。默认为false。建议保持默认值.--&gt; &lt;property name="testOnReturn" value="$&#123;redis.testOnReturn&#125;"/&gt; &lt;!-- testWhileIdle:向调用者输出“链接”对象时，是否检测它的空闲超时；默认为false。如果“链接”空闲超时，将会被移除。建议保持默认值. --&gt; &lt;!-- whenExhaustedAction:当“连接池”中active数量达到阀值时，即“链接”资源耗尽时，连接池需要采取的手段, 默认为1(0:抛出异常。1:阻塞，直到有可用链接资源。2:强制创建新的链接资源) --&gt; &lt;/bean&gt; &lt;!-- Spring提供的Redis连接工厂 --&gt; &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" destroy-method="destroy"&gt; &lt;!-- 连接池配置. --&gt; &lt;property name="poolConfig" ref="jedisPoolConfig"/&gt; &lt;!-- Redis服务主机. --&gt; &lt;property name="hostName" value="$&#123;redis.hostName&#125;"/&gt; &lt;!-- Redis服务端口号. --&gt; &lt;property name="port" value="$&#123;redis.port&#125;"/&gt; &lt;!-- Redis服务连接密码. --&gt; &lt;property name="password" value="$&#123;redis.password&#125;"/&gt; &lt;!-- 连超时设置. --&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;"/&gt; &lt;!-- 是否使用连接池. --&gt; &lt;property name="usePool" value="true"/&gt; &lt;/bean&gt; &lt;!-- key序列化 --&gt; &lt;bean id="stringRedisSerializer" class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt; &lt;bean id="stringRedisTemplate" class="org.springframework.data.redis.core.StringRedisTemplate"&gt; &lt;property name="connectionFactory" ref="jedisConnectionFactory"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的访问Redis类. --&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt; &lt;property name="connectionFactory" ref="jedisConnectionFactory"/&gt; &lt;property name="keySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt; &lt;/property&gt; &lt;property name="hashKeySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt; &lt;/property&gt; &lt;property name="valueSerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"/&gt; &lt;/property&gt; &lt;property name="hashValueSerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置缓存 --&gt; &lt;bean id="cacheManager" class="org.springframework.data.redis.cache.RedisCacheManager"&gt; &lt;constructor-arg ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;bean id="redisClient" class="cn.com.servyou.gzyjzx.frame.redis.RedisClient" /&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>JAVA</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用AOP 实现Redis缓存注解，支持SPEL]]></title>
    <url>%2F%2F2017%2F09%2F10%2F%E4%BD%BF%E7%94%A8AOP-%E5%AE%9E%E7%8E%B0Redis%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%94%AF%E6%8C%81SPEL%2F</url>
    <content type="text"><![CDATA[公司项目对Redis使用比较多，因为之前没有做AOP，所以缓存逻辑和业务逻辑交织在一起，维护比较艰难所以最近实现了针对于Redis的@Cacheable，把缓存的对象依照类别分别存放到redis的Hash中，对于key也实现了SPEL支持。 定义缓存注解创建注解，其实大部分数据都是以hash形式存储的（使的key易于管理），所以，注解中定义了fieldKey，用作Hash的field。 12345678910111213/** * 数据缓存注解 */@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DataCacheable &#123; String cacheName() default "";//缓存的名称, 默认取(类名 + 方法名) String[] fieldKey() ;//缓存的字段Key, 使用SPEL支持, 如:#userName long expireTime() default 0; //过期时效(秒) [-1永不过期]&#125; 定义切面,定义PointCut123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.reflect.MethodSignature;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import java.lang.reflect.Method;/** * 数据缓存切面处理 * http://www.cnblogs.com/DajiangDev/p/3770894.html * Created by SIVEN on 17/9/1. */@Aspectpublic class DataCacheableAspect &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 可控的线程池 */ ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10); @Value("#&#123;config['redis.cache.time']&#125;") Long DEFAULT_CACHE_TIME = 600L; //默认10分钟 @Value("#&#123;config['redis.cache.enable']&#125;") boolean REDIS_CACHE_ENABLE;//启用缓存开关 @Resource RedisClient redisClient; /** * 控制业务执行 * * @param joinPoint * @throws Throwable */ @Around("execution(* gov.etax.dzswj.nsrzx.services..service..*.*(..)) &amp;&amp; @annotation(gov.etax.dzswj.nsrzx.component.cache.annotation.DataCacheable)") public Object doAround(ProceedingJoinPoint pjp) throws Throwable &#123; if (!REDIS_CACHE_ENABLE) &#123; logger.debug("缓存开关 &gt;&gt; [禁用]"); return pjp.proceed(); &#125; Method method = getMethod(pjp); DataCacheable cacheable = method.getAnnotation(DataCacheable.class); String hashKey = getHashKey(pjp, cacheable); String fieldKey = parseKey(cacheable.fieldKey(), method, pjp.getArgs()); long expireTime = cacheable.expireTime(); //获取方法的返回类型,让缓存可以返回正确的类型 Class returnType = ((MethodSignature) pjp.getSignature()).getReturnType(); //使用redis 的hash进行存取，易于管理 Object result = redisClient.getMapField(hashKey, fieldKey, returnType); if (result != null) &#123; logger.debug("DataCacheableAspect: doAround() 查找缓存不为空, 返回缓存数据"); setExpireTime(hashKey, expireTime); return result; &#125; result = pjp.proceed(); //后置处理, 将业务数据加入到缓存中 doAfterReturning(hashKey, fieldKey, cacheable.expireTime(), result); return result; &#125; /** * 后置处理方法 (写入缓存) * * @param point * @param returnValue */ private void doAfterReturning(final String hashKey, final String fieldKey, final Long expireTime, final Object result) &#123; //线程处理 fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; logger.debug("DataCacheableAspect: doAfterReturning() 业务处理完毕, 异步将数据或写入缓存中.."); //加入缓存 redisClient.addMap(hashKey, fieldKey, result); //设置失效时长 setExpireTime(hashKey, expireTime); &#125; &#125;); &#125; /** * 重置过期时间 * * @param hashKey * @param expireTime */ private void setExpireTime(final String hashKey, Long expireTime) &#123; //设置失效时长 Long cacheTime = expireTime; if (0 == expireTime) &#123; cacheTime = DEFAULT_CACHE_TIME; &#125; redisClient.expire(hashKey, cacheTime); &#125; /** * 获取被拦截方法对象 * &lt;p&gt; * MethodSignature.getMethod() 获取的是顶层接口或者父类的方法对象 * 而缓存的注解在实现类的方法上 * 所以应该使用反射获取当前对象的方法对象 */ public Method getMethod(JoinPoint pjp) &#123; //获取参数的类型 Object[] args = pjp.getArgs(); Class[] argTypes = new Class[pjp.getArgs().length]; for (int i = 0; i &lt; args.length; i++) &#123; argTypes[i] = args[i].getClass(); &#125; Method method = null; try &#123; method = pjp.getTarget().getClass().getMethod(pjp.getSignature().getName(), argTypes); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; return method; &#125; /** * 获取缓存Hash Key * * @param cacheable * @param point * @return */ private String getHashKey(JoinPoint point, DataCacheable cacheable) &#123; if (StringHelper.isNotEmpty(cacheable.cacheName())) &#123; return cacheable.cacheName(); &#125; Signature signature = point.getSignature(); return signature.getDeclaringTypeName() + "." + signature.getName();//类名 + 方法名 &#125; /** * 获取缓存的key * key 定义在注解上，支持SPEL表达式 * * @param pjp * @return */ private String parseKey(String[] keys, Method method, Object[] args) &#123; //获取被拦截方法参数名列表(使用Spring支持类库) LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer(); String[] paraNameArr = u.getParameterNames(method); //使用SPEL进行key的解析 ExpressionParser parser = new SpelExpressionParser(); //SPEL上下文 StandardEvaluationContext context = new StandardEvaluationContext(); //把方法参数放入SPEL上下文中 for (int i = 0; i &lt; paraNameArr.length; i++) &#123; context.setVariable(paraNameArr[i], args[i]); &#125; StringBuffer parseKeyBuff = new StringBuffer(); for (String key : keys) &#123; parseKeyBuff.append("_").append(parser.parseExpression(key).getValue(context, String.class)); &#125; return parseKeyBuff.toString(); &#125;&#125; RedisClient相关封装参见文章Redis配置 &amp; 常规操作类封装 AOP配置使用示例123456789@Servicepublic class NsrxxServiceImpl implements INsrxxService&#123; @Override @DataCacheable(fieldKey = "#dto.queryObj.djxh") public ResultDto&lt;NsrxxDto&gt; queryNsrxxByDjxh(QueryDto&lt;QueryByDjxh&gt; dto) &#123; INsrxxMapper mapper = SessionTemplateUtil.getMapper(INsrxxMapper.class); return ResultDtoHelper.success(mapper.queryNsrxxByDjxh(dto.getQueryObj())); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
        <category>Spring</category>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea无法下载依赖包的source,使用maven下载source]]></title>
    <url>%2F%2F2017%2F09%2F10%2Fidea%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96%E5%8C%85%E7%9A%84source-%E4%BD%BF%E7%94%A8maven%E4%B8%8B%E8%BD%BDsource%2F</url>
    <content type="text"><![CDATA[问题描述使用Idea时，想查看依赖包的源码，但出现无法下载的提示： idea Sources for ‘spring-context-4.3.2.RELEASE.jar’ not found 解决方法方法1使用Maven命令。经过测试，好用。下载了所有POM里的依赖包的source，这点不是想要的，原来只想下载想看的依赖的source。参考：IDEA-165800 Can’t download dependency’s source code1mvn dependency:resolve -Dclassifier=sources 方法21.下载POM文件依赖的包的source1mvn dependency:sources 2.下载POM文件依赖的包的javadoce1mvn dependency:resolve -Dclassifier=javadoc 3.下载指定依赖包（artifactId）的source。这个很不错，是我想要的。1mvn dependency:sources -DincludeArtifactIds=guava 参考：Get source JARs from Maven repository]]></content>
      <categories>
        <category>JAVA</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring通过ApplicationContext主动获取bean]]></title>
    <url>%2F%2F2017%2F09%2F10%2FSpring%E9%80%9A%E8%BF%87ApplicationContext%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96bean%2F</url>
    <content type="text"><![CDATA[最近在做项目的时候我发现一个问题：Spring的IOC容器不能在Web中被引用(或者说不能被任意地引用)。我们在配置文件中让Spring自动装配，但并没有留住ApplicationContext的实例。我们如果希望在我们的项目中任何位置都能拿到同一个ApplicationContext来获取IOC容器中的资源，就要让Spring将上下文环境填充到我们能获取的地方，比如下面的做法： 方法一: 实现自ApplicationContextAware接口 方法二，使用了注解和静态化的方式来产生SpringFactory对象 方法一: 实现自ApplicationContextAware接口自定义一个工具类，实现自ApplicationContextAware接口，接口的方法是setApplicationContext，我们实现它，并让其为我们服务，因为Spring在load自己的时候会将上下文环境填充进来。我们所要做的就是将得到的ApplicationContext保存下来用。 关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; public class SpringContextUtil implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; /** * 实现ApplicationContextAware接口的context注入函数, 将其存入静态变量. */ public void setApplicationContext(ApplicationContext applicationContext) &#123; SpringContextUtil.applicationContext = applicationContext; // NOSONAR &#125; /** * 取得存储在静态变量中的ApplicationContext. */ public static ApplicationContext getApplicationContext() &#123; checkApplicationContext(); return applicationContext; &#125; /** * 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型. */ @SuppressWarnings("unchecked") public static &lt;T&gt; T getBean(String name) &#123; checkApplicationContext(); return (T) applicationContext.getBean(name); &#125; /** * 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型. */ @SuppressWarnings("unchecked") public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; checkApplicationContext(); return (T) applicationContext.getBeansOfType(clazz); &#125; /** * 清除applicationContext静态变量. */ public static void cleanApplicationContext() &#123; applicationContext = null; &#125; private static void checkApplicationContext() &#123; if (applicationContext == null) &#123; throw new IllegalStateException("applicaitonContext未注入,请在applicationContext.xml中定义SpringContextHolder"); &#125; &#125; &#125; SPRING配置上文的类就是我们要用的，而其中的setApplicationContext是接口中需要实现的，Spring会自动进行填充。我们在Spring的配置文件中注册一下：1&lt;bean id="springContextUtil" class="xxx.xx.SpringContextUtil" /&gt; 使用示例这样就可以了，Spring把我们需要的东西给我们了。我们就可以在需要的地方这样做：1YouClass obj = (YouClass)SpringUtil.getObject("beanid"); 方法二，使用了注解和静态化的方式来产生SpringFactory对象上文的方法有个麻烦的地方：需要配置。而Spring2.5及之后的版本实际上加入了注解的方式进行依赖项的注入，使用如下代码也许更好：123456789101112131415161718192021222324252627282930public class SpringContextUtil extends SpringBeanAutowiringSupport &#123; @Autowired private BeanFactory beanFactory; //静态方法初始化类 private static SpringContextUtil instance; static &#123; instance = new SpringContextUtil(); &#125; //根据bean的id，获取对应类对象 //根据bean的id获取bean对象要比根据class获取bean对象效率高，但容易出现人为错误 public &lt;T&gt; T getBean(String beanId) &#123; return (T)beanFactory.getBean(beanId); &#125; //根据bean的类型，获取对应类对象， //不容易出现认为错误，但效率不如根据id获取bean对象，因为spring内部是把class转换为name，然后再进行查找 @SuppressWarnings(&#123;"unchecked", "rawtypes"&#125;) public &lt;T&gt; T getBean(Class&lt;T&gt; classT) &#123; return beanFactory.getBean(classT); &#125; public static SpringContextUtil getInstance() &#123; return instance; &#125;&#125; 注解扫描如果使用@Autowired注解自动装配的话，继承SpringBeanAutowiringSupport类是不能少的。当然，使用@Component等注解也是可以的。使用注解的话配置就需要改动了，不过因为我们为支持Spring注解的配置是可以多用的，所以还好。如下：1&lt;context:component-scan base-package="org.ahe"&gt;&lt;/context:component-scan&gt; 配置即可让org.ahe下所有包(您依然可以通过子标签的正则表达式匹配来进行更多设置)下的注解起作用。 使用示例这样就可以了，Spring把我们需要的东西给我们了。我们就可以在需要的地方这样做：12MyTestBean myTestBean = (MyTestBean ) SpringUtil.getInstance().getBean(MyTestBean.class);MyTestBean myTestBean1 = (MyTestBean) SpringUtil.getInstance().getBean("myTestBean"); 系统初始化无法获取bean目前又做了个系统初始化的东东SystemInit，然后发现上面的getBean()用不了了。看了下发现是因为在系统初始化的时候SpringContextUtil还没有初始化，导致在SystemInit类里面的东西getBean()失败。于是小改造了下，把ApplicationContextAware放在SystemInit类，然后注入到SpringContextUtil，这样就保证了在执行系统初始化方法之前，applicationContext一定不是null。 SpringContextUtil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * spring上下文配置 * @author Mingchenchen * */public class SpringContextUtil &#123; private static Logger logger = Logger.getLogger(SpringContextUtil.class); //@Autowired 沿用springTest的这种方法 是否会更好？ //ApplicationContext ctx; private static ApplicationContext applicationContext = null; public static void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; SpringContextUtil.applicationContext = applicationContext; &#125; //注意此处变成了static public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; /** * 注意 bean name默认 = 类名(首字母小写) * 例如: A8sClusterDao = getBean("k8sClusterDao") * @param name * @return * @throws BeansException */ public static Object getBean(String name) throws BeansException &#123; return applicationContext.getBean(name); &#125; /** * 根据类名获取到bean * @param &lt;T&gt; * @param clazz * @return * @throws BeansException */ @SuppressWarnings("unchecked") public static &lt;T&gt; T getBeanByName(Class&lt;T&gt; clazz) throws BeansException &#123; try &#123; char[] cs=clazz.getSimpleName().toCharArray(); cs[0] += 32;//首字母大写到小写 return (T) applicationContext.getBean(String.valueOf(cs)); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; public static boolean containsBean(String name) &#123; return applicationContext.containsBean(name); &#125; public static boolean isSingleton(String name) throws NoSuchBeanDefinitionException &#123; return applicationContext.isSingleton(name); &#125;&#125; 系统初始化代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Descripties: 系统初始化 * @author wangkaiping * 2016年5月23日 上午11:58:09 */@Componentpublic class SystemInit implements InitializingBean,ApplicationContextAware&#123; private static Logger logger = Logger.getLogger(SystemInit.class); @Autowired private ClusterDao clusterDao; @Override public void afterPropertiesSet() throws Exception &#123; logger.info("--------------系统初始化中-------------------"); initClusterCache();//初始化集群数据 必须最开始完成 initRefreshAppStatusTask(); initUpdateAppStatusToDB(); initUpdateSession(); logger.info("--------------系统初始化完成-------------------"); &#125; /** * 1.初始化集群数据 */ private void initClusterCache()&#123; logger.info("1.初始化集群信息到缓存中:ClusterCache开始"); //查询数据库所有的集群数据 List&lt;ClusterEntity&gt; allClusterInfoList = clusterDao.selectAll(ClusterEntity.class, "delete_flag=0"); for (ClusterEntity k8sClusterEntity : allClusterInfoList) &#123; ClusterCache.put(k8sClusterEntity.getUuid() , k8sClusterEntity);//存入缓存 &#125; logger.info("1.初始化集群信息到缓存中:ClusterCache完成,总共" + allClusterInfoList.size() + "条数据"); &#125; /** * 2.初始化异步任务:刷新所有应用状态 */ private void initRefreshAppStatusTask() &#123; logger.info("2.初始化任务:RefreshAllAppStatusTask 刷新应用下的k8s的pod状态并存入待更新队列"); RefreshAppStatusExcutor.init(); logger.info("2.初始化任务:RefreshAllAppStatusTask 完成"); &#125; /** * 3.初始化异步任务:更新状态到数据库 */ private void initUpdateAppStatusToDB() &#123; logger.info("3.初始化任务:RefreshToDBTask 从待更新Appinstance队列取出数据并更新数据库"); UpdateAppStatusToDBExcutor.init(); logger.info("3.初始化任务:RefreshToDBTask 完成"); &#125; /** * 4. 初始化异步任务： 更新用户的所有session */ private void initUpdateSession() &#123; logger.info("4.初始化任务：更新session开始"); UserSessionUpdateExcutor.init(); logger.info("4.初始化任务：更新session结束"); &#125; //////////////////////////////////////////////////////////////// //此方法一定不要写成static @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; //实际上是把applicationContext传入到了SpringContextUtil里面 SpringContextUtil.setApplicationContext(applicationContext); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3 整合MyBatis3 配置多数据源 动态选择SqlSessionFactory]]></title>
    <url>%2F%2F2017%2F09%2F10%2FSpring3-%E6%95%B4%E5%90%88MyBatis3-%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90-%E5%8A%A8%E6%80%81%E9%80%89%E6%8B%A9SqlSessionFactory%2F</url>
    <content type="text"><![CDATA[摘要Spring整合MyBatis切换SqlSessionFactory有两种方法，第一、 继承SqlSessionDaoSupport，重写获取SqlSessionFactory的方法。第二、继承SqlSessionTemplate 重写getSqlSessionFactory、getConfiguration和SqlSessionInterceptor这个拦截器。其中最为关键还是继承SqlSessionTemplate 并重写里面的方法。 而Spring整合MyBatis也有两种方式，一种是配置MapperFactoryBean，另一种则是利用MapperScannerConfigurer进行扫描接口或包完成对象的自动创建。相对来说后者更方便些。MapperFactoryBean继承了SqlSessionDaoSupport也就是动态切换SqlSessionFactory的第一种方法，我们需要重写和实现SqlSessionDaoSupport方法，或者是继承MapperFactoryBean来重写覆盖相关方法。如果利用MapperScannerConfigurer的配置整合来切换SqlSessionFactory，那么我们就需要继承SqlSessionTemplate，重写上面提到的方法。在整合的配置中很多地方都是可以注入SqlSessionTemplate代替SqlSessionFactory的注入的。因为SqlSessionTemplate的创建也是需要注入SqlSessionFactory的。 实现代码继承SqlSessionTemplate 重写getSqlSessionFactory、getConfiguration和SqlSessionInterceptor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326import static java.lang.reflect.Proxy.newProxyInstance;import static org.apache.ibatis.reflection.ExceptionUtil.unwrapThrowable;import static org.mybatis.spring.SqlSessionUtils.closeSqlSession;import static org.mybatis.spring.SqlSessionUtils.getSqlSession;import static org.mybatis.spring.SqlSessionUtils.isSqlSessionTransactional; import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.sql.Connection;import java.util.List;import java.util.Map; import org.apache.ibatis.exceptions.PersistenceException;import org.apache.ibatis.executor.BatchResult;import org.apache.ibatis.session.Configuration;import org.apache.ibatis.session.ExecutorType;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.RowBounds;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.MyBatisExceptionTranslator;import org.mybatis.spring.SqlSessionTemplate;import org.springframework.dao.support.PersistenceExceptionTranslator;import org.springframework.util.Assert; /** * &lt;b&gt;function:&lt;/b&gt; 继承SqlSessionTemplate 重写相关方法 * @author hoojo * @createDate 2013-10-18 下午03:07:46 * @file CustomSqlSessionTemplate.java * @package com.hoo.framework.mybatis.support * @project SHMB * @blog http://blog.csdn.net/IBM_hoojo * @email hoojo_@126.com * @version 1.0 */public class CustomSqlSessionTemplate extends SqlSessionTemplate &#123; private final SqlSessionFactory sqlSessionFactory; private final ExecutorType executorType; private final SqlSession sqlSessionProxy; private final PersistenceExceptionTranslator exceptionTranslator; private Map&lt;Object, SqlSessionFactory&gt; targetSqlSessionFactorys; private SqlSessionFactory defaultTargetSqlSessionFactory; public void setTargetSqlSessionFactorys(Map&lt;Object, SqlSessionFactory&gt; targetSqlSessionFactorys) &#123; this.targetSqlSessionFactorys = targetSqlSessionFactorys; &#125; public void setDefaultTargetSqlSessionFactory(SqlSessionFactory defaultTargetSqlSessionFactory) &#123; this.defaultTargetSqlSessionFactory = defaultTargetSqlSessionFactory; &#125; public CustomSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123; this(sqlSessionFactory, sqlSessionFactory.getConfiguration().getDefaultExecutorType()); &#125; public CustomSqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType) &#123; this(sqlSessionFactory, executorType, new MyBatisExceptionTranslator(sqlSessionFactory.getConfiguration() .getEnvironment().getDataSource(), true)); &#125; public CustomSqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; super(sqlSessionFactory, executorType, exceptionTranslator); this.sqlSessionFactory = sqlSessionFactory; this.executorType = executorType; this.exceptionTranslator = exceptionTranslator; this.sqlSessionProxy = (SqlSession) newProxyInstance( SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor()); this.defaultTargetSqlSessionFactory = sqlSessionFactory; &#125; @Override public SqlSessionFactory getSqlSessionFactory() &#123; SqlSessionFactory targetSqlSessionFactory = targetSqlSessionFactorys.get(CustomerContextHolder.getContextType()); if (targetSqlSessionFactory != null) &#123; return targetSqlSessionFactory; &#125; else if (defaultTargetSqlSessionFactory != null) &#123; return defaultTargetSqlSessionFactory; &#125; else &#123; Assert.notNull(targetSqlSessionFactorys, "Property 'targetSqlSessionFactorys' or 'defaultTargetSqlSessionFactory' are required"); Assert.notNull(defaultTargetSqlSessionFactory, "Property 'defaultTargetSqlSessionFactory' or 'targetSqlSessionFactorys' are required"); &#125; return this.sqlSessionFactory; &#125; @Override public Configuration getConfiguration() &#123; return this.getSqlSessionFactory().getConfiguration(); &#125; public ExecutorType getExecutorType() &#123; return this.executorType; &#125; public PersistenceExceptionTranslator getPersistenceExceptionTranslator() &#123; return this.exceptionTranslator; &#125; /** * &#123;@inheritDoc&#125; */ public &lt;T&gt; T selectOne(String statement) &#123; return this.sqlSessionProxy.&lt;T&gt; selectOne(statement); &#125; /** * &#123;@inheritDoc&#125; */ public &lt;T&gt; T selectOne(String statement, Object parameter) &#123; return this.sqlSessionProxy.&lt;T&gt; selectOne(statement, parameter); &#125; /** * &#123;@inheritDoc&#125; */ public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey) &#123; return this.sqlSessionProxy.&lt;K, V&gt; selectMap(statement, mapKey); &#125; /** * &#123;@inheritDoc&#125; */ public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey) &#123; return this.sqlSessionProxy.&lt;K, V&gt; selectMap(statement, parameter, mapKey); &#125; /** * &#123;@inheritDoc&#125; */ public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds) &#123; return this.sqlSessionProxy.&lt;K, V&gt; selectMap(statement, parameter, mapKey, rowBounds); &#125; /** * &#123;@inheritDoc&#125; */ public &lt;E&gt; List&lt;E&gt; selectList(String statement) &#123; return this.sqlSessionProxy.&lt;E&gt; selectList(statement); &#125; /** * &#123;@inheritDoc&#125; */ public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123; return this.sqlSessionProxy.&lt;E&gt; selectList(statement, parameter); &#125; /** * &#123;@inheritDoc&#125; */ public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; return this.sqlSessionProxy.&lt;E&gt; selectList(statement, parameter, rowBounds); &#125; /** * &#123;@inheritDoc&#125; */ public void select(String statement, ResultHandler handler) &#123; this.sqlSessionProxy.select(statement, handler); &#125; /** * &#123;@inheritDoc&#125; */ public void select(String statement, Object parameter, ResultHandler handler) &#123; this.sqlSessionProxy.select(statement, parameter, handler); &#125; /** * &#123;@inheritDoc&#125; */ public void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) &#123; this.sqlSessionProxy.select(statement, parameter, rowBounds, handler); &#125; /** * &#123;@inheritDoc&#125; */ public int insert(String statement) &#123; return this.sqlSessionProxy.insert(statement); &#125; /** * &#123;@inheritDoc&#125; */ public int insert(String statement, Object parameter) &#123; return this.sqlSessionProxy.insert(statement, parameter); &#125; /** * &#123;@inheritDoc&#125; */ public int update(String statement) &#123; return this.sqlSessionProxy.update(statement); &#125; /** * &#123;@inheritDoc&#125; */ public int update(String statement, Object parameter) &#123; return this.sqlSessionProxy.update(statement, parameter); &#125; /** * &#123;@inheritDoc&#125; */ public int delete(String statement) &#123; return this.sqlSessionProxy.delete(statement); &#125; /** * &#123;@inheritDoc&#125; */ public int delete(String statement, Object parameter) &#123; return this.sqlSessionProxy.delete(statement, parameter); &#125; /** * &#123;@inheritDoc&#125; */ public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; return getConfiguration().getMapper(type, this); &#125; /** * &#123;@inheritDoc&#125; */ public void commit() &#123; throw new UnsupportedOperationException("Manual commit is not allowed over a Spring managed SqlSession"); &#125; /** * &#123;@inheritDoc&#125; */ public void commit(boolean force) &#123; throw new UnsupportedOperationException("Manual commit is not allowed over a Spring managed SqlSession"); &#125; /** * &#123;@inheritDoc&#125; */ public void rollback() &#123; throw new UnsupportedOperationException("Manual rollback is not allowed over a Spring managed SqlSession"); &#125; /** * &#123;@inheritDoc&#125; */ public void rollback(boolean force) &#123; throw new UnsupportedOperationException("Manual rollback is not allowed over a Spring managed SqlSession"); &#125; /** * &#123;@inheritDoc&#125; */ public void close() &#123; throw new UnsupportedOperationException("Manual close is not allowed over a Spring managed SqlSession"); &#125; /** * &#123;@inheritDoc&#125; */ public void clearCache() &#123; this.sqlSessionProxy.clearCache(); &#125; /** * &#123;@inheritDoc&#125; */ public Connection getConnection() &#123; return this.sqlSessionProxy.getConnection(); &#125; /** * &#123;@inheritDoc&#125; * @since 1.0.2 */ public List&lt;BatchResult&gt; flushStatements() &#123; return this.sqlSessionProxy.flushStatements(); &#125; /** * Proxy needed to route MyBatis method calls to the proper SqlSession got from Spring's Transaction Manager It also * unwraps exceptions thrown by &#123;@code Method#invoke(Object, Object...)&#125; to pass a &#123;@code PersistenceException&#125; to * the &#123;@code PersistenceExceptionTranslator&#125;. */ private class SqlSessionInterceptor implements InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; final SqlSession sqlSession = getSqlSession( CustomSqlSessionTemplate.this.getSqlSessionFactory(), CustomSqlSessionTemplate.this.executorType, CustomSqlSessionTemplate.this.exceptionTranslator); try &#123; Object result = method.invoke(sqlSession, args); if (!isSqlSessionTransactional(sqlSession, CustomSqlSessionTemplate.this.getSqlSessionFactory())) &#123; // force commit even on non-dirty sessions because some databases require // a commit/rollback before calling close() sqlSession.commit(true); &#125; return result; &#125; catch (Throwable t) &#123; Throwable unwrapped = unwrapThrowable(t); if (CustomSqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) &#123; Throwable translated = CustomSqlSessionTemplate.this.exceptionTranslator .translateExceptionIfPossible((PersistenceException) unwrapped); if (translated != null) &#123; unwrapped = translated; &#125; &#125; throw unwrapped; &#125; finally &#123; closeSqlSession(sqlSession, CustomSqlSessionTemplate.this.getSqlSessionFactory()); &#125; &#125; &#125;&#125; 重写后的getSqlSessionFactory方法会从我们配置的SqlSessionFactory集合targetSqlSessionFactorys或默认的defaultTargetSqlSessionFactory中获取Session对象。而改写的SqlSessionInterceptor 是这个MyBatis整合Spring的关键，所有的SqlSessionFactory对象的session都将在这里完成创建、提交、关闭等操作。所以我们改写这里的代码，在这里获取getSqlSessionFactory的时候，从多个SqlSessionFactory中获取我们设置的那个即可。 上面添加了targetSqlSessionFactorys、defaultTargetSqlSessionFactory两个属性来配置多个SqlSessionFactory对象和默认的SqlSessionFactory对象。 CustomerContextHolder 设置SqlSessionFactory的类型123456789101112131415161718192021222324252627282930/** * &lt;b&gt;function:&lt;/b&gt; 多数据源 * @author hoojo * @createDate 2013-9-27 上午11:36:57 * @file CustomerContextHolder.java * @package com.hoo.framework.spring.support * @project SHMB * @blog http://blog.csdn.net/IBM_hoojo * @email hoojo_@126.com * @version 1.0 */public abstract class CustomerContextHolder &#123; public final static String SESSION_FACTORY_MYSQL = "mysql"; public final static String SESSION_FACTORY_ORACLE = "oracle"; private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;String&gt;(); public static void setContextType(String contextType) &#123; contextHolder.set(contextType); &#125; public static String getContextType() &#123; return contextHolder.get(); &#125; public static void clearContextType() &#123; contextHolder.remove(); &#125; &#125; 配置相关的文件applicationContext-session-factory.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;bean id="mysqlDataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- Filters --&gt; &lt;!-- &lt;property name="filters" value="config,stat" /&gt; &lt;property name="connectionProperties" value="config.decrypt=true" /&gt; --&gt; &lt;property name="filters" value="stat" /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="1" /&gt; &lt;property name="minIdle" value="1" /&gt; &lt;property name="maxActive" value="20" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="60000" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt; &lt;property name="validationQuery" value="SELECT 'x'" /&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;property name="testOnReturn" value="false" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name="poolPreparedStatements" value="false" /&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="20" /&gt; &lt;/bean&gt; &lt;!-- 数据源2 --&gt; &lt;bean id="oracleDataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name="driverClassName" value="$&#123;dataSource2.driver&#125;" /&gt; &lt;property name="url" value="$&#123;dataSource2.url&#125;" /&gt; &lt;property name="username" value="$&#123;dataSource2.username&#125;" /&gt; &lt;property name="password" value="$&#123;dataSource2.password&#125;" /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="1" /&gt; &lt;property name="minIdle" value="1" /&gt; &lt;property name="maxActive" value="20" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="60000" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt; &lt;property name="validationQuery" value="SELECT 'x' FROM DUAL" /&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;property name="testOnReturn" value="false" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name="poolPreparedStatements" value="true" /&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="20" /&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="stat" /&gt; &lt;/bean&gt; &lt;bean id="oracleSqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="oracleDataSource"/&gt; &lt;property name="configLocation" value="classpath:mybatis/mybatis-config.xml"/&gt; &lt;!-- mapper和resultmap配置路径 --&gt; &lt;property name="mapperLocations"&gt; &lt;list&gt; &lt;!-- 表示在com.hoo目录下的任意包下的resultmap包目录中，以-resultmap.xml或-mapper.xml结尾所有文件 --&gt; &lt;value&gt;classpath*:/mapper/TestMapper.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactoryBean --&gt; &lt;bean id="mysqlSqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="mysqlDataSource"/&gt; &lt;property name="configLocation" value="classpath:mybatis/mybatis-config.xml"/&gt; &lt;!-- mapper和resultmap配置路径 --&gt; &lt;property name="mapperLocations"&gt; &lt;list&gt; &lt;!-- 表示在com.hoo目录下的任意包下的resultmap包目录中，以-resultmap.xml或-mapper.xml结尾所有文件 （oracle和mysql扫描的配置和路径不一样，如果是公共的都扫描 这里要区分下，不然就报错 找不到对应的表、视图）--&gt; &lt;value&gt;classpath:com/zlzkj/app/mapper/*-mapper.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置自定义的SqlSessionTemplate模板，注入相关配置 --&gt; &lt;bean id="sqlSessionTemplate" class="com.zlzkj.app.support.CustomSqlSessionTemplate"&gt; &lt;constructor-arg ref="mysqlSqlSessionFactory" /&gt; &lt;property name="targetSqlSessionFactorys"&gt; &lt;map&gt; &lt;entry value-ref="oracleSqlSessionFactory" key="oracle"/&gt; &lt;entry value-ref="mysqlSqlSessionFactory" key="mysql"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过扫描的模式，扫描目录在com/hoo/任意目录下的mapper目录下，所有的mapper都需要继承SqlMapper接口的接口 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注意注入sqlSessionTemplate --&gt; &lt;property name="sqlSessionTemplateBeanName" value="sqlSessionTemplate"/&gt; &lt;property name="basePackage" value="com.zlzkj.app.mapper,com.zlzkj.core.mybatis,com.zlzkj.app.omapper" /&gt; &lt;/bean&gt; Sercice测试调用1234567CustomerContextHolder.setContextType(CustomerContextHolder.SESSION_FACTORY_ORACLE); try &#123; Test test = mapper.selectByPrimaryKey((short)1); System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;"+test.getName()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 好了，如果数据能读出来，那就恭喜你，你配置多数据源成功了。 注解支持使用注解方式, 动态配置数据源 自定义定义注解:123456789101112131415161718192021222324/** * 切换数据源 * 在service impl方法进行注解 */@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface SwitchDataSource &#123; DataSoure value() default DataSoure.gt3;&#125;/** * 数据源 */public enum DataSoure &#123; //mysql数据源 mysql, //oracle数据源 oracle&#125; AOP拦截注解使用业务前置的方式,对业务方法进行切面处理123456789101112131415161718192021/** * 多数据源切面处理 */@Aspectpublic class SwitchDataSourceAspect &#123; @Before(value = "execution(* gov.etax.dzswj.nsrzx.services..service..*.*(..)) and @annotation(gov.etax.dzswj.nsrzx.services.common.datasource.annotation.SwitchDataSource))") public void doBefore(JoinPoint joinPoint) throws Throwable &#123; Signature signature = joinPoint.getSignature(); MethodSignature methodSignature = (MethodSignature) signature; Method method = methodSignature.getMethod(); if (method != null) &#123; SwitchDataSource annotation = method.getAnnotation(SwitchDataSource.class); //设置数据源 CustomerContextHolder.setContextType(annotation.value().name()); return; &#125; CustomerContextHolder.clearContextType(); &#125;&#125; 调用示例123456789101112131415161718/** * 纳税人信息查询服务实现类 * @author SIVEN * @version 1.0 */@Servicepublic class NsrxxServiceImpl implements INsrxxService&#123; @Override @SwitchDataSource(DataSoure.gt3) public ResultDto&lt;NsrxxDto&gt; queryNsrxxByDjxh(QueryDto&lt;QueryByDjxh&gt; dto) &#123; //int i = 1 /0; INsrxxMapper mapper = SessionTemplateUtil.getMapper(INsrxxMapper.class); return ResultDtoHelper.success(mapper.queryNsrxxByDjxh(dto.getQueryObj())); &#125;&#125; 参考文章: Spring3 整合MyBatis3 配置多数据源 动态选择SqlSessionFactory Spring+Mybatis多数据源配置mysql+oracle]]></content>
      <categories>
        <category>JAVA</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Mybatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让Mac也能拥有apt-get类似的功能——Brew]]></title>
    <url>%2F%2F2017%2F09%2F05%2F%E8%AE%A9Mac%E4%B9%9F%E8%83%BD%E6%8B%A5%E6%9C%89apt-get%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94Brew%2F</url>
    <content type="text"><![CDATA[原文地址：http://snowolf.iteye.com/blog/774312 之前一直怀念ubuntu下的apt-get，因为实在是方便，需要安装什么，一个命令搞定，相关的依赖包统统由apt-get维护。下载，编译，安装，那叫一个痛快。什么软件用着不爽，一个命令卸载！ 怀念apt-get之余，发现了替代工具MacPorts，据说也可以解决我的问题。但可惜，我总是无法更新本地软件索引库！ homebrew主页对brew进行了详细的描述，不过我们更希望下载下来实战演练！ 1.安装brew：1curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/local --strip 1 上述命令，在官网上可以找到！ 2.使用brew安装软件别的工具不说，wget少不了，但是mac上默认没有！就先拿它来开刀了： 1brew install wget 甚至是安装tomcat： 1brew install tomcat 3.使用brew卸载软件安装简单，卸载就更简单了： 1brew uninstall unrar 4.使用brew检索软件看看我们能搜到什么： 1brew search /apache*/ /apache*/使用的是正则表达式，注意使用/分隔！]]></content>
      <categories>
        <category>MAC OS</category>
      </categories>
      <tags>
        <tag>MAC OS</tag>
        <tag>Brew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两台Linux服务器之间通过SCP传输文件夹（无须密码验证）]]></title>
    <url>%2F%2F2017%2F09%2F05%2F%E4%B8%A4%E5%8F%B0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E9%80%9A%E8%BF%87SCP%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%88%E6%97%A0%E9%A1%BB%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原文参考：http://buddie.iteye.com/blog/1988730 最近因工作需要，要在两台Linux服务器之间传输文件夹。Linux命令选择是SCP，SCP命令的基本格式如下： 1scp -p port user@serverip:/home/user/filename /home/user/filename 以上端口p 为参数，port 端口；user 为远程服务器的用户；serverip 为远程服务器ip或者域名；第一个/home/user/filename 为要传输的远程服务器的文件名；第二个/home/user/filename 为本地服务服务器的文件名。 如果端口是默认，则可省略-p port；如果传传输的为文件夹，则要加-r参数。如下所示：1scp -r user@serverip:/home/user/folder /home/user/folder 以上是从serverip这台服务器上下载文件夹/home/user/folder到本服务器的/home/user/folder中。如果要从本地上传文件夹到远程服务器，那就是下面的类似指令： 1scp -r /home/user/folder user@serverip:/home/user/folder 这样就实现了两台Linux服务器之间的文件、文件夹传输。 可是每次都要输入密码验证，很麻烦。为了不用每次输入密码验证，需要在两个服务器这间建立互信通信。首先，使用ssh-keygen生成密钥文件和私钥文件1ssh-keygen -t rsa 其中rsa为一种加密方式，另一种为dsa这时，服务器会提醒你输入密钥文件的文件名，默认为/root/.ssh/id_rsa直接回车这时，服务器会提醒你输入密码。如果想以后通过该密钥在两台服务器这间通信时，不需要再输入密码的话，这个时候，就不用输入任务字符，直接回车就好！系统会再确认一下密码，仍然回车。这样就在/root/.ssh/目录下，生成了id_rsa.pub和id_rsa两上文件。 接下来，就要将id_rsa.pub文件上传到目标服务器的/root/.ssh/目录下，重命名为authorized_keys 1scp -r /root/.ssh/id_rsa.pub user@serverip:/root/.ssh/authorized_keys 这时，输入目标服务器的密码，待文件传输完成后即可。如果目标服务器上，已经存在了authorized_keys，那么就将id_rsa.pub中的内容追加到目标服务器的authorized_keys文件中 1cat /root/.ssh/id_rsa.pub | ssh user@serverip 'cat &gt;&gt; /root/.ssh/authorized_keys' 此时，再使用scp在这两台服务器这间传输文件，只有第一次，需要输入密码外，以后就再也不用输入密码验证了。]]></content>
      <categories>
        <category>Linux</category>
        <category>SCP</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%2F2017%2F09%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
</search>
